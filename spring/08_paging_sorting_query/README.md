# 08_paging_sorting_query

### Цель

Понять, как в Spring Data JPA работают Paging/Sorting запросы. Написать ендпоинт для paging/sorting запросов.

### Теория

Начинаем окунаться в дебри работы с базами данных в Spring. Spring Data вообще говоря включает в себя
целую свору самых разных хранилищ. Посмотреть их и их документации можно [здесь[1]](https://spring.io/projects/spring-data#overview).

А вот [здесь[2]](https://github.com/spring-projects/spring-data-examples) можно посмотреть тысячи тысяч примеров работы 
с JPA практически по всем поддерживаемым технологиям.

Тут тебе и прямая работа с JDBC (ура!), и работа с generic key-value хранилищами, и REST, и Касандра, и еще целая куча всего.
Внутри ссылки выше есть ссылки на github репозитории каждого из проектов. В них в ридми описано что каждый из них делает, 
а также приводятся ссылки на конкретные документации по каждому из продуктов.

Мы с вами будем говорить о ```Spring Data JPA```, а конкретно в самой стандартной связке - Spring + Hibernate. В общем целом 
JPA (Java Persistence API) - это спецификация, первая версия которой была предложена аж в 2006 году. И состоит она из 3 кусков:
- Собственно, API, находящийся в пакете ```javax.persistence```
- Язык запросов JPQL (Java Persistence Query Language)
- Правила объектно-реляционного отображения (ORM)

Hibernate является одной из имплементация JPA, которая наиболее часто используется в сочетании со Spring.

Важно заметить, что ORM в общем и JPA в частности - это не единственный способ общаться с базой данных. Существует много 
других крутых, прозрачных и удобных способ взаимодействия с базами данных. (Один из них - JDBC Template, мы рассмотрим в следующих 
выпусках). Как правило, их можно разделить на 3 категории:
- ORM фреймворки типо Hibernate и Sormula
- Фреймворки, работающие с нативными запроса, типо Spring JDBC Template и sql2o
- Фреймворки, предоставляющие DSL для написания SQL запросов, типо JOOQ.

При работе с БД, выбор фреймворка как правило упирается в 1 вопрос - нужен или не нужен очень серьезный перфоманс. Если
нужен - просто берем любой нативный фреймворк. Они все очень многословные, но нативные фреймворки совершенно точно будут 
самым производительным решением. Если же речь идет о проекте, где перфоманс - не самая главная состовляющая, то имеет 
смысл подумать над разными вариантами и выбрать тот, который подходит команде лучше всего. Более подробно про выбор подхода
к работе с БД можно почитать [здесь[3]](https://dzone.com/articles/jpa-hibernate-alternatives)

#### Java Persistence

Java Persistence API состоит из нескольких кусочков:
1. **EntityManagerFactory** - factory класс для создания инстансов ```EntityManager```
2. **EntityManager** - интерфейс, отвечающий за работу с persistence context. Помимо управления ```Entity``` внутри 
 persistence context, он также является фабриков для ```Query```. Самый популярный менеджер в Hibernate - это класс ```Session```
3. **Entity** - сущность, которую можно сохранять и получать из базы данных. Сущности идентифицируются внутри 
persistence context по ID (внутри одного контекста может быть только 1 сущность с данным ID).
4. **EntityTransaction** - сущность по работе с транзакциями, которую можно получить из ```EntityManager```. Здесь 
1-к-1 мапинг между ```EntityTransaction``` и ```EntityManager```, но это не значит, что реальные транзакции в базу тоже
буду мапится, как 1 к 1. Реальная имплементация сама вольна выбирать способ мапинга JPA транзакций к транзакциям БД
5. **Persistence** - bootstrap класс, из которого можно получить ```EntityManagerFactory```. Его же можно использовать
для генерации схемы
6. ```Query``` - интерфейс, служащий для непосредственного исполнения запросов.

###### Тут когда-нибудь будет скучный раздел с теорией про сотни аннотаций в ```@Entity```.
А пока можно почитать какую-нибудь книжку, например вот [эту[4]](https://www.manning.com/books/java-persistence-with-hibernate-second-edition)

#### Spring Data JPA with Hibernate

Подключить Spring Data JPA в Springboot проект очень просто - нужно добавить зависимость на стартер, а также зависимость
на используемую базу, например вот так:
```
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
    </dependency>
```

Такое подключение поумолчанию также начнет использовать Hibernate в качестве реализации JPA. Главной абстракцией, которую
даже Spring Data JPA, является интерфейс ```Repository```. Основной его потомок, который используется в большинстве проектов -
```JpaRepository```. Последний из коробки поддерживает работу с пагинацией и сортировкой. 

А теперь внимание вопрос - вот у нас есть метод ```Page<T> findAll(Pageable pageable)```. Как бы передать в него параметры
из внешнего мира? Ответ очень простой - вот так:
```
    @GetMapping("/myApi")
    @HasAnyRole
    public Page<MyEntity> getByEntities(Pageable pageable) {
            return this.myObjectRepository.findAll(pageable);
    }
```

Т.е. мы указываем интефрейс ```Pageable``` в качестве аргумента метода в ```GetMapping```. Как мы помним это значит, что
параметры, которые есть в этом классе, должны быть переданы в качестве аргументов урла. Но это же интефрейс!

Но на самом деле все просто. У этого интерфейса есть реализация ```PageRequest```. В ней есть 2 поля для пагинации
```
	private final int page;
	private final int size;
```

И еще объект ```Sort``` для сортировки. Объект ```Sort``` состоит из нескольких полей, но нам важно лишь поле ```List<Order> orders```. 
В свою очередь объет ```Order``` - это набор полей
```
    private final Direction direction;
    private final String property;
    private final boolean ignoreCase;   
    private final NullHandling nullHandling;
```

Подстава здесь заключается в том, что на текущий момент из этого списка автоматически резолвятся только property и direction.
 ignoreCase и nullHandling необходимо руками преврщать в значения. Как минимум пока не закрыта issue https://jira.spring.io/browse/DATACMNS-658.
 Резолвинг происходит в классе спринговом классе ```SortHandlerMethodArgumentResolver``` - его метод ```public Sort resolveArgument```. 

Таким образом, получается что мы можем сконструировать запрос к api с пагинацией и сортировкой следующим образом:
```/myApi?page=0&size=10&sort=firstname,ASC&sort=lastname&sort=age,DESC```

Добавить туда ignoreCase и nullHandling пока что нельзя.

При этом маппинг property в имя и direction в направление сортировки при конструировании объекта ```Sort``` 
произойдет автоматически. Как правило весь этот код по конструированию правильных параметров урла нужно написать на 
фронте один раз, а затем везде переиспользовать.

### Почитать

1. Какие хранилища поддерживаюьтся из коробки в Spring Data https://spring.io/projects/spring-data#overview
2. Пример Spring Data https://github.com/spring-projects/spring-data-examples
3. Альтернативы JPA при выборе технологии работы с базами https://dzone.com/articles/jpa-hibernate-alternatives
4. Java Persistence with Hibernate. Manning https://www.manning.com/books/java-persistence-with-hibernate-second-edition

### Задание

Есть контроллер ```MyEntityController``` с единственным методом вызовом GET /myEntity. Необходимо:
1) Организовать поддержку пагинации и сортировке при вызове
2) Конструировать и возвращать объект ```PageWithTotalResponse``` в качестве ответа на запрос

(Необязательно) Бонусные очки даются за поддежку функциональности ignoreCase и nullHandling. (Note: в общем случае её сделать не так-то и сложно. 
Вопрос только в формате принимаемых данных).

(Необязетльно 2) Еще бонусные очки тому, кто по исходникам ```SortHandlerMethodArgumentResolver``` поймет, почему в настоящий 
момент резолвится только ```property``` и ```direction```
