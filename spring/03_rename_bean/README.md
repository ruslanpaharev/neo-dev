# 03_rename_bean

### Цель

Понять, как создаются бины во время инициализации контекста, и как можно влиять на этот процесс.

### Теория

Одним из самых главных (и самых сложны) этапов создания ```ApplicationContext``` в спринге является создания и наполнение
```BeanFactory```, а именно - создание бинов.

Бины создаются в несколько фаз, которые можно расставить в таком порядке

1. Сначала так или иначе считываются описания всех бинов ```BeanDefinition``` (Это интерфейс спринга. Можно в него 
перейти и почитать что это). Раньше для этого использовался XML, теперь все чаще - аннотации. Бин дефинишины можно 
считывать даже из проперти файлов или из груви скриптов. Механизм вполне себе кастомизируется, поэтому считывать их в 
теории можно практически откуда угодно  (например можно посмотреть спринг-потрошитель 
[здесь[1]](https://www.youtube.com/watch?v=BmBr5diz8WA). Там же сравнение скорости инициализации контекса с XML и с 
аннотациями (спойлер - XML парсить быстрее).
2. Затем ```BeanFactory``` с начитанными дефинишинами обрабатывается в нескольких ```BeanFactoryPostProcessor```. 
Имплементации этих интерфейсов применяются один за другим, чтобы каким-то образом изменить ```BeanDefinition```. В качестве изменений можно:
    - задавать и удалять проперти бинов, 
    - заменять один ```BeanDefinition``` на другой, 
    - добавлять новые ```BeanDefinition```, 
    - Помечать бины, как ```Primary``` 
    - и еще много чего. 
  
    Важно: на этом этапе НЕЛЬЗЯ создавать инстансы бинов.  Только подменять определение. 
    В стандартном спринге очень много разных ```BeanFactoryPostProcessor``` с длиннющими названиями, например 
```EmbeddedDataSourceBeanFactoryPostProcessor```, который подменяет реальный ```DataSource``` встроенным. 
3. Далее идет непосредственно процесс создания бина. В этом помогают ```BeanPostProcessor```. При помощи этого интерфейса можно обернуть бины
в прокси (что спринг делает для всех сервисов, например) или инициализировать неинициализированные интерфейсы. BeanPostProcessor имеет 2 метода - 
```postProcessBeforeInitialization``` и ```postProcessAfterInitialization```. А еще есть констуктор бина и ```@PostConstruct```. В итоге инициализация 
происходит следующим образом:
    1. Сначала вызывает ```postProcessBeforeInitialization```. Он вызывается на бине, которому уже проставили проперти.
    2. Затем вызывается констуктор бина
    3. Затем ```@PostConstruct``` (это же называется init-метод)
    4. После этого вызывается ```postProcessAfterInitialization```
Очень частой схемы работы ```BeanPostProcessor``` является начитывание списка бинов с некоторым маркером в ```postProcessBeforeInitialization```,
а затем создание прокси над этими бинами в ```postProcessAfterInitialization```. Более подробно можно посмотреть в спринг-потрошителе 
(ссылка есть выше).
4. После этого шага, каждый бин вызывает евент ```ContextRefreshedEvent```. Его можно перехватить и например вызвать какой-нибудь метод
только что созданного бина.

##### Когда использовать 
Обычно для хаков :)

Пример можно посмотреть [здесь[2]](https://bravenewgeek.com/a-look-at-springs-beanfactorypostprocessor/)
И конечно же в спринг-потрошителе.

Как правило, если хочется использовать перечисленные выше интерфейсы - то либо существует более простой путь, либо вы
реально знаете, что делаете. Или пишите свою библиотеку.

#### Пара слов про работу с бинами и их создание

Пока не планируется детально рассматривать различные способы создания бинов и их inject'а, поэтому здесь будет небольшая вижимка.

Когда бин создается - создается сначала некий прокси для объекта, который используется как бин. Прокси бывают CGLIB и 
Dynamic JDK Proxy. Первый работает через создание подкласса от целевого метода, а второй - через реализацию того 
же интерфейса. Чаще используется первый метод.

Так что любой ваш ```@Service``` и ```@Bean``` - это на самом деле прокси-класс. Делается так специально, потому что 
именно на уровне обертки можно:
- Управлять скоупом бина (поумолчанию в Spring singleton. А вообще их много, посмотреть можно [здесь[3]](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes), а в потрошителе можно посмотреть, как делать свои) 
- Разрешать зависимости при создании бинов
- Обнаруживать циклические зависимости при инициализации контекста в случае, если используется constructor-injection.
- etc

А что из этого разработчику? Главные вещи, о которых стоит помнить, следующие:
- ```instanceOf``` (который и так не надо использовать) будет для классов Service/Bean/etc возвращать не то, что вы ожидаете.
- Это же справедливо для классов, помеченных, как ```@Entity```, но не всегда, а только если эти классы не 
инициализированы полностью (Например в них есть ленивые коллекции)
- !!! ```@Transactional``` НЕ БУДЕТ РАБОТАТЬ, если он стоит над ```private```,  методом (```private``` метод не 
попадает в прокси-класс-наследник, потому что наследование так не работает (сл-но CGLIB не работает). 
В интерфейсах private методов вообще нет (вернее не было до java 10), поэтому не работает Dynamic JDK Proxy). 
- !!! ```@Transactional``` НЕ БУДЕТ РАБОТАТЬ, если он стоит над ```protected``` или ```package-private``` методом (```protected``` 
метод хоть и попадает в прокси-класс-наслед, но с ним может работать только CGLIB, а не Dynamic JDK Proxy, 
т.к. в интерфейсах не может быть protected методов. А package-private методов не бывает в интерфейсах (они все public). Поэтому командой спринга принято решение НЕ ПОДДЕРЖИВАТЬ protected/package-private методы вообще). Одним словом - ```@Transactional``` будет работать ТОЛЬКО над публичными методами.
- !!! ```@Transactional``` НЕ БУДЕТ РАБОТАТЬ, если он вызывается ВНУТРИ бина. (Потому что при вызове ```@Transactional``` 
на самом деле вызывается AOP Proxy (подробнее см. в 4 задании). Если один бин вызывает внутри 
себя свой метод - такой вызов не происходит из контекста спринга, а происходит напрямую - соответственно 
вызова AOP Proxy не произойдет). Пример:
```
@Service
public class MyService {

	public void doTransaction() {

		/* НЕ СРАБОТАЕТ! Траназкция не будет создана / поддержана. 
			При этом ошибкой это тоже не будет считать. 
			Можно получить поведение, которого вы не ожидаете!
		*/
		executeTransaction();  
	}

	@Transactional 
	public void executeTransaction() {
		<... some call with multiple DB queries which should go in single transaction but will actually go OUT of transaction (each call will create a 
transaction of it's own ...>
	}
}
```
- Аналогичным образом будет работать (или не работать) любое другое поведение, завязанное на вызов бинов из контекста. Следует помнить, что вызов одного бина из другог и вызов 2 методов внутри одного бина - это принципиально разные с точки зрения спринга вещи.

Все перечисленное выше для ```@Transactional``` верно, когда он работает в режиме Spring AOP. Если использовать AspectJ вместо Spring AOP поведение будет меняться. См доку: [здесь[4]](https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations)

##### Как создавать бины

Во-первых, есть 2 способа создания бина через аннотации:
- Создания бина в классе, с пометкой ```@Configuration```. Это полное создание бина с прокси и всем прочим.
- Создание бина в классе, с пометкой ```@Component```. Это lite версия создания бина. Такой бин не оборачивается в прокси при создании. При создании бина таким
образом нельзя делать хаки типо
```
@Component
public class Config {
    
    public BeanA beanA() {
        return new BeanA();
    }

    public BeanB beanB() {
        return new BeanB(beanA());
    }
}
```

Подробнее можно почитать в Javadoc к аннотации ```@Bean```

##### Как инжектить бины

Есть 3 способа инжекса бинов:
- Через констуктор
- Через getter / setter
- Через филды

True-way созданием бинов является создание их через констуктор. Это позволяет на раннем этапе обнаруживать циклические зависимости + при позволяет очень просто мокать бин. Пример:

```
@Service 
public class MyDependency {
	
}

@Service
public class MyDepUser {

	private final MyDependency myDependency;

	public MyDepUser (MyDependency myDependency) {
		this.myDependency = myDependency;
	}
}
```

Если не хочется писать все эти констукторы самому - можно воспользоваться замечательной библиотечкой [Lombok[5]](https://projectlombok.org/). Тогда код получится совсем простой
```
@Service 
@RequiredArgsConstructor // Создась констуктор со всемми необходимыми полями, т.е. final полями
public class MyDepUser{
	private final MyDependency myDependency;
}
```

Также можно пометить класс, исопльзуемый как инъекция, аннотацийе ```@Autowired```. Это не нужно делать с какой-то бородатой версии спринга, но это МОЖНО делать (Note: создавать лишние связи с используемым фреймворком - это плохая идея. Если можно не делать Spring-specific вещи - лучше их не делать)

Если по каким-то причинам (которые ну никаааак нельзя решить) создать зависимость через конструктор не удается - можно воспользоваться ```@Autowired``` над сеттером

```
@Service
public class MyDepUser {

	private MyDependency myDependency;

	public MyDepUser () {}

	@Autowired
	public void setMyDependency(MyDependency myDependency) {
		this.myDependency = myDependency;
	}
}
```

### Почитать / Посмотреть

1. Посмотреть Спринг-потрошитель Евгения Борисова. Возможно лучший рускоязычный спискер по спирнгу.
    1. https://www.youtube.com/watch?v=BmBr5diz8WA 
    2. https://www.youtube.com/watch?v=cou_qomYLNU
    3. https://www.youtube.com/watch?v=yy43NOreJG4
    4. https://www.youtube.com/watch?v=7Cq5zEm2wq0
2. Рассказ о том, как заставить тесты НЕ ПОДНИМАТЬ под собой tomcat, а использовать тот же tomcat, который разработчик 
 использует во время разработки https://bravenewgeek.com/a-look-at-springs-beanfactorypostprocessor/. Используется веселая 
 магия с ```BeanFactoryPostProcessor```, считыванием jar'ов из файлов и прочими радостями
3. Скопы бинов https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-scopes
4. Документация ```@Transactional``` https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction-declarative-annotations
5. Project lombok https://projectlombok.org/

### Задание

Есть класс ```ShapeShifter``` с проперти ```myProp```. Он создается в конфигурации ```BeansConfig``` 
Значение проперти задается в файле ```application.property```. Неободимо написать ```BeanFactoryPostProcessor```, 
который превратит установит ```myProp = 10```. Note: по факту ```@Value``` не делает автоматически из "просто переменной" 
проперти с точки зрения спринга. Поэтому эту проперти нельзя просто так взять и вытащить при помощи ```BeanFactoryPostProcessor```.
Тем неменее проперти работают как мапы, так что её можно "переписать".

NOTE: Задачу можно решить и при помощи подмена проперти, и при помощи изменение значения переменной после создания бина и даже
 вызовом сеттера после создания бина и перехватат соответствующего евента. Любой метод будет считаться правильным.
Единственное условие - код решения не должен трогать файл ```application.properties```, класс ```ShapeShifter``` и ```класс BeansConfig```

Тест должен проходить.
