# 07_spring_security

### Цель

Немного раскурить Spring Security. Понять, как можно вставлять кастомные security фильтры в процесс авторизации.

### Теория

Web-приложения довольно уязвимы к различным видам атак. Это объясняется не только сложностью инстументов, при помощи
которых строятся современные приложение (больше сложности - больше шансов накосячить), но также и фундаменьтальной 
сложностью процессов, которые автоматизируются этими приложениями. 

Риски и ущерб, нанесенный уязвимостями веб приложений, тоже очень сильно варьируются в масштабах. Утечка пользовательских 
данных может иметь значительные репутационные потеря, но также может облагаться большими государственными штрафами. Отказ
в обслуживании может не нанести ущерба вообще, а может привести к потярем миллионов долларов.

Проблема безопасности дополнительно осложняется сложностью тестирования приложений на безопасность. Легко проверить, что
приложение выполняют заложенную в него функцию. Проверить, что приложениие не выполняет ни единой НЕ заложенной в него функции 
напротив, очень сложно, если вообще возможно.

Вообще пре безопасность можно говорить бесконечно. В качестве хорошего и очень плотного ознакомления рекомендую 
посмотреть [курс MIT по безопасности приложений[1]](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/video-lectures/)

#### С чего начинается "Безопасность"

В безопасности очень любят число 3...

Есть три основные цели безопасности:
- **Конфиденциальность** - поддержание возможности доступа только для тех пользователь, которые должны иметь такой доступ  (Что также завуалировано 
утверждает  необходимость наличия способа идентификации пользователя). Пример атаки: неавторизированный пользователь может 
читать данные других пользователей за счет SQL инъекций.
- **Целостность** - поддержания правдивости информации, а также источников этой информации. Пример атаки: при переходе на сайт
компании пользователь попадает на сайт злоумышленника.
- **Доступность** - ифнормация должна быть доступная аутентифицированному/авторизированному (о том, что такое 
аутентификация/авторизация будет ниже) пользователю всегда, когда предполагается, что она доступна. Пример атаки: создание 
нагрузки на приложение, приводящее к отказу в обслуживании всем остальным клиентам.

Более подробно [здесь[2]](https://developer.mozilla.org/en-US/docs/Web/Security/Information_Security_Basics/Confidentiality,_Integrity,_and_Availability)

Предполагается, что организация будем внедрять безопасность в 3 этапа:
- **Построение модели угроз**. Т.е. определить кем является атакующий и какие у него в распоряжении есть инстументы
(Пример: любой человек с доступом к публичному интефрейсу системы. Или суперадминистратор системы с доступом из локальной сети)
- **Создание политики безопасности**. Т.е. набор поведений, которые мы считаем приемлимыми. (Пример: только авторизированный
пользователь с ролью АДМИНИСТРАТОР должен иметь возможность удалять других пользователей)
- **Использование методов безопаности**. Т.е. какими техническими средствами обеспечивается безопаность (Пример: использование
JWT токена для аутентификации/авторизации при взаимодействии с stateless бекендом)

#### Безопасность Web

При разработке web приложений мы как правило имеем дело с пунктом 3 - методами безопасности. Но следует помнить что любой
метод на самом деле должен существовать во имя удовлетворения критериям полики безопасности (другими словами - "секъюрити
ради секъюрити" - это путь провалов, тормозов и небезопасных приложений).

При работе веб приложений мы как правило имеет дело с пользователями и их ролями. С точки зрения безопасности существует 3 
этапа работы с пользователем
1. **Идентификация** - это процесс/способ при помощи которого мы определяем сущность, инициирующую запрос. В качестве
средства идентификации можно, например, использовать JWT токен. Тогда наличие токена при запросе будет является шагом идентификации
2. **Аутентификация** - проверка того что пользователь является тем, за кого он себя выдает. После идентификации необходимо 
удостоверится, что индентифицируемая сущность является "валидной". В случае с JWT - это проверка токена на валидность.
3. **Авторизация** - проверка возможности выполнения тех или иных действий аутентифицированной сущностью. Авторизация 
говорит что может, а чего не может делать пользователь. Как правило авторизация тесно связана с ролями пользователей.

О безопасности Web приложений можно говорить долго. Одним из самых хороших открытых ресурсов по безопасности на текущий 
момент является сайт [OWASP[3]](https://www.owasp.org/index.php/Main_Page). Особенно рекомендую к прочтению материал
Owasp TOP TEN 2017 (гуглится). Это презентация про основные уязвимости веб приложений 2017 года, способы их обнаружения
и устранения.

Теперь рассмотрим подходы к организации решений проблем безопасности в Spring приложениях.

#### Spring Security

Spring Security - это кастомизируемый фреймворк аутентификации и авторизации. Полная дока есть [здесь[4]](https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/).

Дока по архитектуре, которая в кратце будет описана ниже присутствует [здесь[5]](https://spring.io/guides/topicals/spring-security-architecture)

Аутентификация в Spring Security начинается с интерфейса ```AuthenticationManager``` (Как и всегда рекомендуется переходить на 
указанные интерфейсы и смотреть javadoc'и к классам). Он может аутентифицировать запрос или кинуть одну из нескольких ошибок (см. 
javadoc для подробностей):
1. Вернуть объект ```Authentication``` обычно с с полем ```authenticated=true```
2. Выкинуть одну из ```AuthenticationException```
3. Вернуть ```null```, если невозможно сделать вывод по поводу аутентификации.

Как правило в качестве имплементации используется класс ```ProviderManager``` - Это менеджер, который делегирует 
аутентификацию цепочке из ```AuthenticationProvider```. При этом элементом цепочки может быть еще 1 ```ProviderManager```.
 Каждый из них может сделать тоже самое, что и оригинальный ```AuthenticationManager```, т.е. либо вернуть 
 объект ```Authentication```, либо кинуть ошибку, либо вернуть ```null```.
 
Одним из таких провайдеров, например, является ```DaoAuthenticationProvider```, который используется ```UserDetailsService``` для
 получения информации о пользователе в какой-то кастомный объект.

```AuthenticationManager``` можно кастомизировать, расширяя ```WebSecurityConfigurerAdapter```. При этом можно кастомизировать, 
как самый верхнеуровневый ```AuthenticationManager``` (обычно не требуется до тех пор, пока это РЕАЛЬНо требуется), либо 
создавая его потомков. См ссылку 5 для подробностей.

---

Далее происходит аутентификация запроса. Аутентификацией занимается имплементации ```AccessDecisionManager```. Эти имплементации
в свою очередь используют цепочку из ```AccessDecisionVoter``` для принятия решения. Решения принимаются последовательным вызовом 
методов vote в цепочке
```
int vote(Authentication authentication, S object,
           Collection<ConfigAttribute> attributes);
```

Это мотод содержит ```object``` - сущность к которой пытается получить доступ пользователь и ```attributes``` набор параметров,
обладая которыми пользователь может получить доступ к сущности. Одним из параметром может быть, например, роль в виде "ROLE_ADMIN".

---
В случае с безопасностью в Web в игру вступают Servlet API и его фильтры. Весь Spring Security в Web представлен с точки
зрения Servlet API в виде 1 фильтра - ```FilterChainProxy```. Но с точки зрения Spring этот фильтр на самом деле является
цепочкой из нескольких фильтром. Каждый фильтр внутри ```FilterChainProxy``` ровно как и каждый фильтр внутри Servlet API
может модицифировать параметры запроса, может передать запрос дальше в следующий фильтр, а может и сам обработать запрос.

В ```WebSecurityConfigurerAdapter``` можно задавать дополнительные кастомные фильтры. Именно это нужно будет сделать в 
задании к данной части курса

Основной способ работы с авторизацией в Spring Security - это через аннотации ```@Secured/@PreAuthorize```. Чтобы активировать
эти аннотации, необходимо пометить один из классов-конфигураций как:
```java
@SpringBootApplication
@EnableGlobalMethodSecurity(securedEnabled = true)
public class SampleSecureApplication {
}
```

Теперь мы можем ограничивать доступ к методам только тем пользователям, у которых есть соответствующие роли, например:
```
@PreAuthorize("hasAnyRole('ROLE_ADMIN', 'ROLE_SUPER_ADMIN')")
public String onlyAdminOrSuperAdminRoleEndpoint() {}
```


---

Еще немного информации. Текущего пользователя можно получить из статического класса ```SecurityContextHolder```. Пользователи
биндятся к треду, а это значит, что для передачи пользователя в асинхронный контект, необходимо заранее предусмотреть такую
возможность. Например для работы с аннотацией ```@Async``` необходимо создать особый executor следующим образом:

```
@Configuration
public class ApplicationConfiguration extends AsyncConfigurerSupport {
    @Override
    public Executor getAsyncExecutor() {
        return new DelegatingSecurityContextExecutorService(Executors.newFixedThreadPool(5));
    }
}
```

Целую кучу туториалов по Spring Security на все случаи жизни можно раздобыть [здесь[6]](https://www.baeldung.com/security-spring)

#### JWT Токен

Раз уж мы уже упомянули JWT токен раз 15, давайте все-таки поговорим о том, что это такое.

JWT (Json Web Token) - это компактный способ передачи параметров аутентификации/авторизации (claims) между двумя клиентами. 
JWT определен стандартом [RFC 7519[7]](https://tools.ietf.org/html/rfc7519). JWT токен состоит из 3 кусков, разделенных
через точку - header, в котором прописан алгоритм, payload - полезные данные запроса и signature - подпись токена.

JWT сделан с расчетом на то что проверка подписи - быстрая операция, а генерация нового токена - медленная. JWT может
быть подписан как с использованием 1 приватного ключа (например алгоритм HS512), что удобно использовать как правило если 
во взаимоедйствии участвует максимум 2-3 системы (фронтенд с браузера и бекенд, например), так и с использованием 1 приватного
и одного публичного ключа (Например RS512). Такой подход лучше работает, когда в системе есть выделенный ```auth-сервер```,
отвечающий за создание новый токенов при помощи приватного  ключа и N других сервисов, которым нужно лишь проверять этот 
токен при помощи публичного ключа.

[Здесь[8]](https://jwt.io/) про JWT можно почитать еще. 

[Здесь[9]](https://github.com/aquatir/code-samples/tree/master/code-sample-angular-kotlin/code-sample-jwt-token-example) 
 и [Здесь[10]](https://github.com/szerhusenBC/jwt-spring-security-demo) можно посмотреть примеры реализации работы с JWT токеном с 1 приватным ключом.

### Почитать

1. MIT безопасность приложений https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/video-lectures/
2. Цели безопасности https://developer.mozilla.org/en-US/docs/Web/Security/Information_Security_Basics/Confidentiality,_Integrity,_and_Availability
3. Сайт Owasp https://www.owasp.org/index.php/Main_Page
4. Дока Spring Security https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/
5. Дока по артихектуре Spring Security https://spring.io/guides/topicals/spring-security-architecture
6. Тысячи туториалов по security https://www.baeldung.com/security-spring
7. JWT стандарт https://tools.ietf.org/html/rfc7519
8. Поддержка JWT https://jwt.io/
9. Пример реализации аутентификации/атворизации с JWT на Kotlin https://github.com/aquatir/code-samples/tree/master/code-sample-angular-kotlin/code-sample-jwt-token-example
10. Пример реализации аутентификации/авторизации с JWT на Java https://github.com/szerhusenBC/jwt-spring-security-demo

### Задание

Дано приложение с basic-auth. В приложении существует 2 пользователя user1 и user2. Необходимо cоздать свой кастомный фильтр, 
который будет сразу кидать ```IllegalArgumentException```, в случае, если в ендпоинт в MySecureController обращается 
user2 (мы ненавидимо user2). 

Note: В общем случае пользователь хочет получить какое-то внятное сообщение об ошибке, поэтому просто кидать 
Exception и не обрабатывать его, скорее всего не самая хорошая идея. Здесь мы будем так делать исключетельно в учебных целях.
